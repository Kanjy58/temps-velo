#! /usr/bin/env nix-shell
#! nix-shell -i python3 -p "python3.withPackages(ps: with ps; [pandas scipy requests (python3Packages.callPackage ./openrouteservice-py.nix {})])"

import sys
import pandas as pd
import requests
from time import sleep
from scipy.spatial import Delaunay
from threading import Lock
import pickle
from pathlib import Path
import openrouteservice
import json

# Nomitatim rate limit (requests per minutes)
# https://operations.osmfoundation.org/policies/nominatim/
nominatim_rate_limit = 60

# openrouteservice rate limit (requests per minutes)
# https://openrouteservice.org/plans/
# https://openrouteservice.org/restrictions/
openrouteservice_rate_limit  = 40

# openrouteservice API key
OPENROUTESERVICEKEY = open('openrouteservice.key', 'r').readlines()[0].rstrip()

# filter out lines exceeding this time (should filter long exterior edges of triangulation)
maxminutes = 60


nominatim_mutex = Lock()

def write_cache(cache):
    pickle.dump(cache, open('cache.p', 'wb'))

def getLatLng(s):
    # caching by query
    if s['query'] in cache['nominatim']:
        print('[cached] nominatim request for {}'.format(s['name']), file=sys.stderr)
        return cache['nominatim'][s['query']]
    else:
        nominatim_mutex.acquire()

        print('nominatim request for {}'.format(s['name']), file=sys.stderr)
        json = requests.get(url="https://nominatim.openstreetmap.org/search?limit=1&format=jsonv2&q={}".format(s['query'])).json()

        sleep(60 / nominatim_rate_limit)
        nominatim_mutex.release()

        cache['nominatim'][s['query']] = json[0]['lat'], json[0]['lon']
        write_cache(cache)

        return json[0]['lat'], json[0]['lon']

# Read cache
if Path('cache.p').is_file():
    cache = pickle.load(open('cache.p', 'rb'))
else:
    cache = {
        'nominatim': {},
        'openrouteservice': {}
    }

# read wanted points
points = pd.read_csv('points.tsv', delimiter='\t')

# do requests to Nominatim to get points' coordinates
points[['lat', 'lng']] = points.apply(getLatLng, axis=1, result_type='expand')

# compute Delaunay triangulation
triangles = Delaunay(points[['lat', 'lng']]).simplices

# get all unique edges
edges = set()
for triangle in triangles:
    edges.add(tuple(sorted([triangle[0], triangle[1]])))
    edges.add(tuple(sorted([triangle[1], triangle[2]])))
    edges.add(tuple(sorted([triangle[0], triangle[2]])))

# get trip time for each edge
lines = []
client = openrouteservice.Client(key=OPENROUTESERVICEKEY)
for p1, p2 in edges:
    coords = ((points.iloc[p1].lng, points.iloc[p1].lat),
            (points.iloc[p2].lng, points.iloc[p2].lat))

    # caching by coords
    if coords in cache['openrouteservice']:
        print('[cached] openrouteservice request for {} -> {}'.format(points.iloc[p1]['name'], points.iloc[p2]['name']), file=sys.stderr)
        if(cache['openrouteservice'][coords]['minutes'] <= maxminutes):
            lines.append(cache['openrouteservice'][coords])
    else:
        print('openrouteservice request for {} -> {}'.format(points.iloc[p1]['name'], points.iloc[p2]['name']), file=sys.stderr)
        routes = client.directions(coords, profile='cycling-regular')

        minutes = round(routes['routes'][0]['summary']['duration'] / 60)

        # East/west is important to not get text reversed
        if points.iloc[p1].lng < points.iloc[p2].lng:
            west = [points.iloc[p2].lat, points.iloc[p2].lng]
            east = [points.iloc[p1].lat, points.iloc[p1].lng]
        else:
            west = [points.iloc[p1].lat, points.iloc[p1].lng]
            east = [points.iloc[p2].lat, points.iloc[p2].lng]

        res = {
            'west': west,
            'east': east,
            'minutes': minutes
        }

        cache['openrouteservice'][coords] = res;
        write_cache(cache)

        if(minutes <= maxminutes):
            lines.append(res)

        sleep(60 / openrouteservice_rate_limit)

# write results
with open('data.js', 'w') as output:
    output.write('// Autogenerated file, do not edit\n')
    output.write('var points = ')
    output.write(points[['name', 'lat', 'lng']].to_json(orient='records'))
    output.write(';\nvar lines = ')
    output.write(json.dumps(lines))
    output.write(';')
